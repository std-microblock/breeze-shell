import { ClangASTD } from "./clang-ast";
import { existsSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { CTypeParser, cTypeToTypeScript } from "./c-type-parser";

const ast = JSON.parse(readFileSync(join(__dirname, "ast.json"), "utf-8")) as ClangASTD;

const targetFile = 'binding_types.h'
const outputFile = 'binding_qjs.h'
// filter out loc.file contains targetFile

const origFile = readFileSync(join(__dirname, '../../src/shell/script/binding_types.h'), 'utf-8').split('\n').map(v => v.trim())

let binding =
    `// This file is generated by scripts/bindgen/index.ts
// Do not modify this file manually!

#pragma once
#include "binding_types.h"
#include "quickjs.h"
#include "quickjspp.hpp"

template <typename T>
struct js_bind {
    static void bind(qjs::Context::Module &mod) {}
};
`

let typescriptDef = `// This file is generated by scripts/bindgen/index.ts
// Do not modify this file manually!

declare module 'mshell' {

`

const parseFunctionQualType = (type: string) => {
    // std::variant<int, std::string> (std::string, std::string)
    // std::function<void(int, std::string)> (int, std::string)

    enum State {
        ReturnType,
        Args,
        Done
    }

    let state = State.ReturnType;
    let returnType = '';
    let currentArg = '';
    let args: string[] = [];
    let depth = 0;
    let angleBracketDepth = 0;

    for (let i = 0; i < type.length; i++) {
        const char = type[i];

        if (char === '<') {
            angleBracketDepth++;
        } else if (char === '>') {
            angleBracketDepth--;
        }

        switch (state) {
            case State.ReturnType:
                if (char === '(' && angleBracketDepth === 0) {
                    state = State.Args;
                    returnType = returnType.trim();
                } else {
                    returnType += char;
                }
                break;

            case State.Args:
                if (char === '(') depth++;
                if (char === ')') {
                    if (depth === 0 && angleBracketDepth === 0) {
                        if (currentArg.trim()) args.push(currentArg.trim());
                        state = State.Done;
                        break;
                    }
                    depth--;
                }
                if (char === ',' && depth === 0 && angleBracketDepth === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                } else {
                    currentArg += char;
                }
                break;
        }
    }

    if (state !== State.Done) {
        throw new Error('Invalid function type');
    }

    return {
        returnType,
        args
    };
}

if (ast.kind !== 'NamespaceDecl') {
    throw new Error('Root node is not a NamespaceDecl');
}

const structNames: string[] = []

const resolveUnderPath = (path: string[], resolveName: string) => {
    const ns = path.join('::');
    const fullName = `${ns}::${resolveName}`;
    if (structNames.includes(fullName)) {
        return fullName;
    }

    // If not found, we try to find the name under the parent namespace
    if (path.length > 1) {
        const parentPath = path.slice(0, -1);
        const parentFullName = resolveUnderPath(parentPath, resolveName);
        if (parentFullName) {
            return parentFullName;
        }
    }

    // else we return the name as is
    return resolveName;
}

const ctypeToQualified = (type: string, path: string[]) => {
    const parser = new CTypeParser();
    const parsed = parser.parse(type, name=> {
        return resolveUnderPath(path, name)
    });

    return parser.formatToC(parsed);
}

const generateForRecordDecl = (node_struct: ClangASTD, path: string[]) => {
    if (node_struct.kind !== 'CXXRecordDecl') {
        throw new Error('Node is not a RecordDecl');
    }

    const structName = node_struct.name;

    const fields: {
        name: string;
        type: string;
        comment?: string;
    }[] = [];

    const methods: {
        name: string;
        returnType: string;
        args: string[];
        static: boolean;
        comment?: string;
        argNames?: string[];
    }[] = [];

    if (!node_struct.inner) return;

    for (const node of node_struct.inner) {
        if (node.name?.startsWith('$')) continue;

        const lineNum = node.loc?.line;
        // find comment above
        let comment = '';

        if (lineNum) {
            let rangeCommentCnt = 0;
            for (let i = lineNum - 2; i >= 0; i--) {
                const line = origFile[i];
                if (!line) continue;
                if (line.startsWith('//')) {
                    comment = line.substring(2) + '\n' + comment;
                    continue;
                }
                if (line.startsWith('/*')) {
                    rangeCommentCnt++;
                    continue;
                }
                if (line.endsWith('*/')) {
                    rangeCommentCnt--;
                    continue;
                }

                if (rangeCommentCnt === 0) break;
                else comment = line + '\n' + comment;
            }
        }

        if (node.kind === 'FieldDecl') {
            fields.push({
                name: node.name!,
                type: ctypeToQualified(node.type!.qualType, path),
                comment: comment.length > 0 ? comment : undefined
            });
        }

        if (node.kind === 'CXXMethodDecl') {
            const parsed = parseFunctionQualType(node.type!.qualType);

            if (
                ['operator='].includes(node.name!)
            ) continue;

            const argNames: string[] = [];
            if (node.inner) {
                for (const arg of node.inner) {
                    if (arg.kind === 'ParmVarDecl') {
                        argNames.push(arg.name!);
                    }
                }
            }

            methods.push({
                name: node.name!,
                returnType: ctypeToQualified(parsed.returnType, path),
                args: parsed.args.map(arg => ctypeToQualified(arg, path)),
                static: node.storageClass === 'static',
                comment: comment.length > 0 ? comment : undefined,
                argNames
            });
        }
    }

    const fullName = path.join('::') + '::' + structName;

    binding += `
template <> struct qjs::js_traits<${fullName}> {
    static ${fullName} unwrap(JSContext *ctx, JSValueConst v) {
        ${fullName} obj;
    `;

    for (const field of fields) {
        binding += `
        obj.${field.name} = js_traits<${field.type}>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "${field.name}"));
        `;
    }

    binding += `
        return obj;
    }

    static JSValue wrap(JSContext *ctx, const ${fullName} &val) noexcept {
        JSValue obj = JS_NewObject(ctx);
    `;

    for (const field of fields) {
        binding += `
        JS_SetPropertyStr(ctx, obj, "${field.name}", js_traits<${field.type}>::wrap(ctx, val.${field.name}));
        `;
    }

    binding += `
        return obj;
    }
};`;

    /**
     * 
     *   module.class_<MyClass>("MyClass")
                    .constructor<>()
                    .constructor<std::vector<int>>("MyClassA")
                    .fun<&MyClass::member_variable>("member_variable")
                    .fun<&MyClass::member_function>("member_function")
                    .static_fun<&MyClass::static_function>("static_function")
     */
    binding += `
template<> struct js_bind<${fullName}> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<${fullName}>("${structName}")
            .constructor<>()`;
    for (const method of methods) {
        if (method.static) {
            binding += `
                .static_fun<&${fullName}::${method.name}>("${method.name}")`;
        } else {
            binding += `
                .fun<&${fullName}::${method.name}>("${method.name}")`;
        }
    }

    for (const field of fields) {
        binding += `
                .fun<&${fullName}::${field.name}>("${field.name}")`;
    }

    binding += `
            ;
    }

};
    `;

    typescriptDef += `
export class ${structName} {
\t${fields.map(field => {
        let fieldDef = `${field.name}${field.type.startsWith('std::optional') ? '?' : ''
            }: ${cTypeToTypeScript(field.type)}`;

        if (field.comment) {
                fieldDef = `
  /**
  * ${field.comment.trim().split('\n').join('\n  * ')}
  */
  ${fieldDef}
            `
        }

        return fieldDef;
    }).join('\n\t')}
\t${methods.map(method => {
        let methodDef = `${method.static ? 'static ' : ''}${method.name}: ${cTypeToTypeScript(`${method.returnType}(${method.args.join(', ')})`)}`

        // if (method.comment) {
        //     methodDef = method.comment.trim().split('\n').map(v => `// ${v}`).join('\n\t')
        //         + '\n\t' + methodDef;
        // }

        // if (method.argNames) {
        //     methodDef = '// Args: ' + method.argNames.join(', ') + '\n\t' + methodDef;
        // }
        let comments = '';
        if (method.comment) {
            comments += method.comment.trim();
        }
            methodDef = `
/**
  * ${comments.split('\n').join('\n  * ')}
  * @param ${method.args.map((arg    , i) => `${method.argNames![i]}: ${cTypeToTypeScript(arg)}`).join(', ')}
  * @returns ${cTypeToTypeScript(method.returnType)}
  */
  ${methodDef}
            `
        return methodDef;
    }).join('\n\t')}
}
    `;

}


const enumerateStructDecls = (node: ClangASTD, callback, path: string[] = ['mb_shell']) => {
    if (node.kind === 'CXXRecordDecl') {
        if (node.name && node.inner) {
            callback(node, path);
        }
    }

    if (node.inner) {
        for (const child of node.inner) {
            enumerateStructDecls(child, callback, [...path, node.name || '']);
        }
    }
}

enumerateStructDecls(ast, (node, path) => {
    structNames.push(path.join('::') + '::' + node.name!);
})

enumerateStructDecls(ast, (node, path) => {
    if (node.kind === 'CXXRecordDecl') {
        generateForRecordDecl(node, path);
    }
})


binding += `
inline void bindAll(qjs::Context::Module &mod) {
`

for (const structName of structNames) {
    binding += `
    js_bind<${structName}>::bind(mod);
`
}

binding += `
}
`

typescriptDef += `
}
`

declare var __dirname: string;
const paths = [
    join(__dirname, 'src/shell/script'),
    join(__dirname, '../src/shell/script'),
    join(__dirname, '../../src/shell/script')
]

typescriptDef += readFileSync(join(__dirname, 'quickjs-types.txt'), 'utf-8');

for (const path of paths) {
    try {
        if (existsSync(join(path, targetFile))) {
            writeFileSync(join(path, outputFile), binding);
            writeFileSync(join(path, 'binding_types.d.ts'), typescriptDef);
            break;
        }
    } catch (e) {
        console.error(e);
    }
}

rmSync(join(__dirname, 'ast.json'));